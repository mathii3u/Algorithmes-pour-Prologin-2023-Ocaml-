I) Arbres 

1) Généralités 

1.1) Méthode :
Une bonne idée est souvent de renvoyer à l'aide d'une fonction auxilière une partie des calculs fait réccursivement sur les enfants d'un noeud 
Application : exo1 


Exercices :

Exo1 : Anoter les noeuds d'un arbre binaire par la taille du sous arbre dont ils sont la racine 
Solution : Nos enfants se renvoient anotés et renvoient leur taille, ce qui permet de nous anoter nous même et de renvoyer notre taille



Exo2 : Donner la liste des étiquettes d'un arbre binaire dans l'ordre préfixe 

Solution : pour éviter d'avoir à concaténer des liste on a simplement a garder en argument la liste des étiquettes qu'il y a après nous dans le parcours,
en effet l'ordre est: racine :: Sous arbre gauche :: Sous arbre droit
1) On appelle à droite avec la liste vide 
2) On appelle à gauche avec la liste obtenue avec 1)
3) On ajoute la racine 



Exo3 : Reconstruire l'arbre binaire dont on donne la liste des étiquettes (dont les noeuds internes sont distingués, 
cela permet d'avoir unicité) lues dans l'ordre infixe (utile à comprendre pour la sérialisation des arbres, cf code de Huffman)

Solution : On vas s'inspirer de la construction de l'ordre infixe :  Sous arbre gauche :: racine :: Sous arbre droit
donc on veut "consommer" le sous arbre gauche (c'est à dire prendre les éléments de la liste jusqu'à arriver sur une feuille), prendre la racine , consommer le sous arbre droit , accoler tout ça
(On utilise une pile pour stocker les étiquettes mais on pourrait prendre une liste quitte à renvoyer aussi la liste après consommation)

let rec build sous_arbre_gauche pile = 
| pile vide -> sous_arbre_gauche
| pop pile = Feuille -> build Feuille (liste')
| pop pile = Noeud -> sous_arbre_droit = build Vide liste' 
                      build N(Noeud,sous_arbre_gauche, sous_arbre_droit) pile 

Rq : il faut bien comprendre que la pile à été modifiée par les appels réccursifs



Exo4 : Trouver un algorithme tranformant un arbre d'arité quelconque en arbre binaire, et son algorithme réciproque 

Solution : l'idée est de former un peigne droit , dont les noeuds sont la racine et ses fils, et à chacun des noeuds de ce peigne, on ajoute en fils gauche le sous arbre binarisé du fils en question



Exo5 : Anoter les sommets d'un arbre binaire par leur numéro dans l'ordre du parcours en largeur 

Solution : cf le fichier exo5.ml



Exo 6 (théorique) : définir et trouver la valeur des nombres de catalans 

Solution : nombre de mots bien parenthèsés, ou alors le nombre d'arbre binaire non étiquettés à n noeuds internes
1) on a une relation donnée par une somme, se trouve en distinguant les cas sur la taille du sous arbre gauche et droit 
2) on veut une formule liant cn et cn+1 , pour cela on prend un arbre à n+1 sommets, et on lui retire une feuille et le noeud interne auquel elle est liée (disons que c'était son fils gauche), alors en remontant le fils droit , on obtient
un arbre binaire à n noeuds internes, on à clairement une application réciproque, en se souvenant où est le noeud remonté et si c'était un fils gauche ou droit 
ce qui fournit cn+1*(n+1) = 2*(2n+1)*cn , en développant un peu on se rend compte que l'on peut compléter le factoriel et obtenir
cn = 1/(n+1) * n parmis 2n


Exo 7 : donner une relation entre le nombre de noeuds internes et de feuilles d'un arbre k-aire 

Solution : 
n=1 : f = k*1 
n=2 : l'une des feuilles est remplacée par un noeud interne et k feuilles en dessous : k-1 + k = f
n=3 : pareil : k-1 + k-1 + k = f 
on peut donc prévoir une formule du style f = k + (n-1)*(k-1) = = n*(k-1) +1 (on remarque que ça fonctionne bien pour k = 2)
Preuve : on compte de deux façons le nombre d'arrêtes , une fois par le nombre de noeuds qui sont extrémité gauche (n*k), une fois par le nombre d'arrêtes extrémité droite (n +f -1)


2) Arbres Rouge-Noir 

2.1) Le principe :
- Objectif : avoir une structure de donnée qui donne, l'insertion, la suppression et la recherche d'un élément en log(n)
- le pincipe : 
Ce que l'on décrit est possible pour des arbres équilibrés, c'est à dire dont la hauteur est proche de log(n)

